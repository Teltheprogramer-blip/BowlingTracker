function calculateFrameScores(player) {
  const rolls = [];
  player.frames.forEach(frame => {
    [frame.input1, frame.input2, frame.input3].forEach(inp => {
      if (inp && inp.value !== "") rolls.push(inp.value.toUpperCase());
    });
  });

  const frameScores = [];
  let rollIndex = 0;

  for (let f = 0; f < 10; f++) {
    if (rollIndex >= rolls.length) break;
    let first = rolls[rollIndex];
    let second = rolls[rollIndex + 1];
    let third = rolls[rollIndex + 2];

    const firstVal = convertRoll(first);
    let secondVal = second === "/" ? 10 - firstVal : convertRoll(second);
    const thirdVal = convertRoll(third);

    let frameScore = 0;

    if (f < 9) {
      if (first === "X") {
        // Strike: 10 + next two valid rolls
        const bonus1 = nextValidRoll(rolls, rollIndex + 1);
        const bonus2 = nextValidRoll(rolls, rollIndex + 2);
        frameScore = 10 + bonus1 + bonus2;
        rollIndex += 1;
      } else if (second === "/") {
        // Spare: 10 + next valid roll
        const bonus = nextValidRoll(rolls, rollIndex + 2);
        frameScore = 10 + bonus;
        rollIndex += 2;
      } else {
        frameScore = firstVal + secondVal;
        rollIndex += 2;
      }
    } else {
      // 10th frame: sum all rolls entered
      frameScore = firstVal + secondVal + thirdVal;
      rollIndex += (third ? 3 : 2);
    }

    frameScores.push(frameScore);
  }

  return frameScores;
}

function nextValidRoll(rolls, startIndex) {
  for (let i = startIndex; i < rolls.length; i++) {
    const val = rolls[i];
    if (val && val !== "") {
      if (val === "X") return 10;
      if (val === "/") return 10; // special handling will be in calculateFrameScores
      if (val === "-") return 0;
      if (!isNaN(val)) return parseInt(val);
    }
  }
  return 0;
}

function convertRoll(val) {
  if (!val) return 0;
  if (val === "X") return 10;
  if (val === "-") return 0;
  if (!isNaN(val)) return parseInt(val);
  return 0;
}
