function handleFrameInput(player){
  const rolls = [];
  player.frames.forEach(frame=>{
    [frame.input1, frame.input2, frame.input3].forEach(inp=>{
      if(inp && inp.value!=="") rolls.push(inp.value.toUpperCase());
    });
  });

  const frameScores=[];
  let rollIndex=0;

  for(let f=0; f<10; f++){
    if(rollIndex>=rolls.length) break;

    let first=rolls[rollIndex], second=rolls[rollIndex+1], third=rolls[rollIndex+2];
    let firstVal=convertRoll(first), secondVal=convertRoll(second), thirdVal=convertRoll(third);

    // Validation: prevent impossible combination
    if(f<9 && firstVal + (secondVal || 0) > 10 && second!=="/" && first!=="X"){
      alert(`Invalid input in frame ${f+1}: sum of pins cannot exceed 10`);
      return;
    }

    let frameScore=0;

    if(f<9){
      if(first==="X"){
        // Strike: look for next two valid rolls
        let bonus1=nextValidRoll(rolls, rollIndex+1);
        let bonus2=nextValidRoll(rolls, rollIndex+2);
        frameScore=10+bonus1+bonus2;
        rollIndex+=1;
      } else if(second==="/"){
        let bonus=nextValidRoll(rolls, rollIndex+2);
        frameScore=10+bonus;
        rollIndex+=2;
      } else {
        frameScore=firstVal+secondVal;
        rollIndex+=2;
      }
    } else {
      frameScore=firstVal+secondVal+thirdVal;
      rollIndex+=(third?3:2);
    }

    frameScores.push(frameScore);
  }

  let cumScore=0;
  player.frames.forEach((frame,i)=>{
    if(frameScores[i]!==undefined){
      cumScore+=frameScores[i];
      const scoreDiv=frame.querySelector(".score");
      scoreDiv.textContent=cumScore;
      scoreDiv.style.visibility="visible";
      const r1=frame.input1.value.toUpperCase();
      const r2=frame.input2.value.toUpperCase();
      scoreDiv.classList.remove("strike","spare");
      if(r1==="X") scoreDiv.classList.add("strike");
      else if(r2==="/") scoreDiv.classList.add("spare");
    }
  });

  const arc=JSON.parse(player.querySelector("select").value);
  const totalRaw=frameScores.reduce((a,b)=>a+b,0);
  player.querySelector(".totals").textContent=`Raw Total: ${totalRaw} | Final Total: ${totalRaw+arc.handicap}`;

  // Update team totals
  const teamContainer=player.parentNode.classList.contains("team-container") ? player.parentNode : player.parentNode.parentNode;
  if(teamContainer && teamContainer.teamTotalDiv){
    let teamTotal=0;
    teamContainer.querySelectorAll(".player").forEach(p=>{
      const arc=JSON.parse(p.querySelector("select").value);
      const rawTotal=p.querySelector(".totals").textContent.match(/Raw Total: (\d+)/);
      if(rawTotal) teamTotal+=parseInt(rawTotal[1])+arc.handicap;
    });
    teamContainer.teamTotalDiv.textContent=`Team Total: ${teamTotal}`;
  }
}

// Helper: find next valid roll (ignore empty inputs)
function nextValidRoll(rolls,startIndex){
  for(let i=startIndex;i<rolls.length;i++){
    const val=rolls[i];
    if(val && val!=="") return convertRoll(val);
  }
  return 0;
}

function convertRoll(val){
  if(!val) return 0;
  if(val==="X") return 10;
  if(val==="/") return 0; // spare itself will be handled in frame calculation
  if(val==="-") return 0;
  if(!isNaN(val)) return parseInt(val);
  return 0;
}
